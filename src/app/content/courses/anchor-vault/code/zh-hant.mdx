import { ArticleSection } from "@/app/components/ArticleSection/ArticleSection";
import { Codeblock } from "@/app/components/Codeblock/Codeblock";

# 第一章：保險險

![Image Test](/graphics/article-img.webp)

在本課程中，我們將介紹設置 Anchor 開發環境和創建您的第一個程式的基本知識。

<ArticleSection name="Anchor 101" id="anchor-101" />

Anchor 是構建 Solana 程式（智能合約）的領先開發框架，簡化了編寫、測試、部署和與 Solana 程式互動的過程。

通過使用 Anchor，開發人員可以減少樣板代碼，專注於實現其應用程式的特定邏輯，並利用結構化的環境，該環境默認包括安全檢查，例如確保帳戶由正確的程式擁有，並在您的代碼運行之前驗證帳戶數據。

Anchor 使用**聲明式巨集**來簡化處理帳戶、指令數據和錯誤處理的樣板代碼，這些代碼與構建 Solana 程式（或智能合約）相關聯。 一些最重要的巨集包括：

- `declare_id!()`: 指定程式的鏈上地址。
- `#[program]`: 指定包含程式指令邏輯的模組。
- `#[derive(Accounts)]`: 指定指令所需的帳戶以及應如何檢查它們。
- `#[error_code]`: 定義自定義錯誤類型，通過使調試更加簡單來提供幫助。

讓我們看看我們的保險險程式的模板是什麼樣的，然後讓我們更具體地討論每個宏的作用：

<Codeblock lang="rust">
    ```rust
    declare_id!("22222222222222222222222222222222222222222222");

    #[program]
    pub mod blueshift_anchor_vault {
        use super::*;

        pub fn deposit(ctx: Context<VaultAction>, amount: u64) -> Result<()> {
            // ...
            Ok(())
        }

        pub fn withdraw(ctx: Context<VaultAction>) -> Result<()> {
            // ...
            Ok(())
        }
    }

    #[derive(Accounts)]
    pub struct VaultAction<'info> {
        // ...
    }

    #[error_code]
    pub enum VaultError {
        // ...
    }
    ```
</Codeblock>

讓我們從基礎開始：

<ArticleSection name="declare_id!()" isCode={true} id="declare_id_macro" level="h3" />

`declare_id!()` 巨集用於指定程式鏈上地址。 這是一個唯一的公鑰，來自您的錨定專案的 `target` 資料夾中儲存的密鑰對，該密鑰對將用於部署代表智能合約的邏輯和所有數據的 `.so` 檔案本身。

**注意**：它不會是 `22222222222222222222222222222222222222222222`，我們在 Blueshift 智能合約範例中使用此約定僅僅是因為我們的測試框架的工作方式。 在真實場景中，您的鏈上程式 ID 將是您運行 Anchor 命令來創建和構建程式時為您生成的 ID。

<ArticleSection name="#[program]` & `#[derive(Accounts)]" isCode id="program_and_derive_accounts_macros" level="h3" />

對於每個指令，都有一個 `context`，它告訴智能合約在此指令中將使用哪些帳戶。 此外，還可以將自定義數據傳遞到其中，以在指令的邏輯中使用。

在此範例中，`deposit` 和 `withdraw` 指令所需的帳戶是相同的，因此我們將引用相同的 `#[derive(Accounts)]` 結構。 我們將其命名為更「通用」的名稱 `VaultAction`，以表明這些帳戶將用於保險險的所有操作。

現在讓我們更深入地了解 `#[derive(Accounts)]` 巨集：

這就是 `VaultAction` 帳戶的外觀：

```rust
#[derive(Accounts)]
pub struct VaultAction<'info> {
  #[account(mut)]
  pub signer: Signer<'info>,

  #[account(
    mut,
    seeds = [b"vault", signer.key().as_ref()],
    bump,
  )]
  pub vault: SystemAccount<'info>,

  pub system_program: Program<'info, System>,
}
```

如前所述，此巨集定義了特定指令必須存在的帳戶，並添加了安全檢查和輔助函數，可幫助您與它們互動。 這也消除了許多樣板代碼，否則這些代碼會使您的指令變得混亂。

在這種情況下，我們將使用以下類型：

- `Signer<'info>`：檢查此帳戶是否標記為當前交易的簽署者。 通常需要這樣做，因為某些 CPI（跨程式調用）調用需要對帳戶進行簽名才能工作，但它也可以作為一種安全措施，以確保只有公鑰的所有者才能調用此指令。

- `SystemAccount<'info>`：檢查此帳戶是否歸系統程式所有，系統程式是 Solana 上可以保存 lamports（SOL 的最小單位）的基本程式。 這有助於驗證該帳戶是常規的系統擁有的帳戶，而不是另一個程式擁有的帳戶。

- `Program<'info, System>`：通過驗證 `executable` 標誌是否設置為 true 來檢查此帳戶是否為程式，並且還驗證公鑰是否對應於系統程式。 程式始終需要作為 CPI 的帳戶，因為在進行跨程式調用（例如，創建帳戶、傳輸 lamports 等）時，您需要引用正確的鏈上程式。

此外，如您所見，某些帳戶利用 `#[account(...)]` 巨集，該巨集創建輔助程式和其他檢查，可用於簡化代碼執行。 以下是一些範例：

- `mut`：檢查帳戶是否設置為**可變**，如果我們要更改帳戶本身中的某些數據，則需要這樣做。 例如，每當我們將 lamports 從一個帳戶轉移到另一個帳戶時，我們都需要將該帳戶設置為可變，因為 `lamports` 字段將更新以反映新的餘額。

- `seeds` & `bump`：檢查帳戶公鑰是否為**程式派生地址 (PDA)**，該地址是根據 `seeds` 字段中的輸入確定性地派生的。 PDA 由程式控制，而不是由外部擁有的密鑰對控制，它們在 Ed25519 曲線上生成，帶有一個偏移量（**bump**），這是一個單字節，可確保派生的地址不位於有效的 Ed25519 曲線點上，從而使真實用戶無法擁有與該 PDA 對應的私鑰。
  - **PDA 簽名**：由於 PDA 由程式控制，因此如果需要，它們可以在 CPI 調用期間代表程式簽署操作。
  - **儲存數據**：PDA 還可用於在以程式方式派生的地址中儲存數據，從而更易於在指令期間定位和驗證它們。

<ArticleSection name="`#[error_code]`" id="error_code_macro" level="h3" />

`#[error_code]` 巨集，用於在程式內部創建自定義錯誤。

這就是 `VaultError` 錯誤的外觀：

```rust
#[error_code]
pub enum VaultError {
    #[msg("Vault already exists")]
    VaultAlreadyExists,
    #[msg("Invalid amount")]
    InvalidAmount,
}
```

我們可以看到，對於每個錯誤，都會聲明一個自定義枚舉變體，並添加一個 `#[msg(...)]` 巨集來表示一旦觸發該錯誤將記錄的消息。 這使得調試更容易，因為它提供了清晰、描述性的消息，而不是通用的錯誤代碼。

<ArticleSection name="保險險代碼" id="the-vault-code" />

現在我們已經討論了開始創建我們的第一個 Anchor 智能合約所需的所有基本信息，現在是我們深入了解不同的指令邏輯和實現的時候了。

保險險背後的基本思想是可以存入一些東西（在本例中為 lamports），只有「所有者」（存入者）才能在以後提取。 這正是 `deposit` 和 `withdraw` 函數的作用。

在我們開始之前，請確保您的機器上安裝了 Rust 和 Anchor。 如果您不確定如何操作，請查看[官方文檔](https://www.anchor-lang.com/docs/installation)。

確認已安裝 Anchor 和 Rust 後，請在您的終端中運行以下命令：

```
anchor init blueshift_anchor_vault
```

打開新生成的資料夾，您就可以開始編碼了！

<ArticleSection name="Template" id="template" level="h3" />

在開始邏輯之前，複製以下模板並使用它：

```rust
declare_id!("22222222222222222222222222222222222222222222");

#[program]
pub mod blueshift_anchor_vault {
    use super::*;

    pub fn deposit(ctx: Context<VaultAction>, amount: u64) -> Result<()> {
        // ...
        Ok(())
    }

    pub fn withdraw(ctx: Context<VaultAction>) -> Result<()> {
        // ...
        Ok(())
    }
}

#[derive(Accounts)]
pub struct VaultAction<'info> {
    // ...
}

#[error_code]
pub enum VaultError {
    // ...
}
```

<ArticleSection name="Deposit" id="deposit" level="h3" />

以下是 `deposit` 邏輯中發生的情況：
- 它驗證保險險帳戶是否具有零 lamports，從而確保保險險尚不存在。
- 它檢查要存入的金額是否大於創建 `SystemAccount` 所需的最低租金。
- 一旦滿足這些條件，它就會使用系統程式將 lamports 從簽署者轉移到保險險。

```rust
pub fn deposit(ctx: Context<VaultAction>, amount: u64) -> Result<()> {
    require_eq!(ctx.accounts.vault.lamports(), 0, VaultError::VaultAlreadyExists);
    require_gt!(amount, Rent::get()?.minimum_balance(0), VaultError::InvalidAmount);


    transfer(
        CpiContext::new(ctx.accounts.system_program.to_account_info(), 
            Transfer {
                from: ctx.accounts.signer.to_account_info(),
                to: ctx.accounts.vault.to_account_info(),
            }
        ),
        amount,
    )?;

    Ok(())
}
```

`deposit` 指令首先添加一些「要求」，然後再執行任何操作。 這些要求類似於您通過巨集在帳戶結構中進行的檢查，但是由於沒有巨集來處理這些特定條件，因此它們在代碼中使用 Rust 方便創建的 `require!()` 巨集手動處理。

```rust
require_eq!(ctx.accounts.vault.lamports(), 0, VaultError::VaultAlreadyExists);
require_gt!(amount, Rent::get()?.minimum_balance(0), VaultError::InvalidAmount);
```

為了提高可讀性，我們將使用它們的「高級」版本，而不是使用基本 `require!()` 巨集：
- `require_eq!()`：檢查保險險帳戶當前是否持有零 lamports，從而確保之前沒有存入任何資金，並防止多次存入同一個保險險。
- `require_gt!()`：確保我們存入的金額大於 SystemAccount 所需的最低租金。 在 Solana 上，每個帳戶都必須保持一定的餘額（稱為「租金」）才能保持有效。

在這種情況下，為了簡化閱讀，我們將使用 `require_eq` 和 `require_gte`，而不是執行簡單的 `require`，以確保保險險帳戶中存在的 lamports（我們可以通過使用 `ctx.accounts.vault.lamports()` 訪問）為零，從而確保此保險險實際上尚不存在，並確保我們嘗試存入的金額大於創建 SystemAccount 所需的最低 `rent`。 在 Solana 上，我們有 `rent` 的概念，這是帳戶需要存入自身的 lamports 的最小金額，以確保存在。

一旦驗證了這些條件，我們將繼續執行主要邏輯——從簽署者到保險險的簡單 lamports 轉移。 這由系統程式處理，系統程式是處理基本操作（如轉移和帳戶創建）的內置 Solana 程式。 由於 Solana 程式是模塊化的，因此一個程式可以通過跨程式調用 (CPI) 調用另一個程式的指令。

Anchor 通過為系統程式提供輔助函數來簡化此過程，因此 lamports 轉移如下所示：

```rust
use anchor_lang::system_program::{transfer, Transfer};

transfer(
    CpiContext::new(ctx.accounts.system_program.to_account_info(), 
        Transfer {
            from: ctx.accounts.signer.to_account_info(),
            to: ctx.accounts.vault.to_account_info(),
        }
    ),
    amount,
)?;
```

在這裡，我們創建一個 `CpiContext`，指定系統程式和相關的來源和目標帳戶，然後通過傳入 lamports 的數量來執行轉移。

<ArticleSection name="Withdraw" id="withdraw" level="h3" />

以下是 `withdraw` 邏輯中發生的情況：
- 使用系統程式和 PDA 的簽署者功能將 lamports 從保險險轉移到簽署者。

```rust
pub fn withdraw(ctx: Context<VaultAction>) -> Result<()> {
    let bindings = ctx.accounts.signer.key();
    let signer_seeds = &[b"vault", bindings.as_ref(), &[ctx.bumps.vault]];

    transfer(
        CpiContext::new_with_signer(ctx.accounts.system_program.to_account_info(), 
            Transfer {
                from: ctx.accounts.vault.to_account_info(),
                to: ctx.accounts.signer.to_account_info(),
            },
            &[&signer_seeds[..]]
        ),
        ctx.accounts.vault.lamports(),
    )?;

    Ok(())
}
```

這次我們在執行邏輯之前不需要任何要求檢查，因為所有這些驗證都已在帳戶結構中處理。 我們知道要提取的保險險由簽署者「擁有」，因為程式派生地址 (PDA) 種子的生成方式，因為這些種子的一部分包括簽署者的密鑰。 如果此保險險之前已獲得資金，則同一簽署者可以提取存入的任何 lamports。

如前所述，PDA 在它們派生自的同一程式中具有「簽署者」功能。 在這種情況下，我們使用簽署者的公鑰來驗證保險險的所有權，但 PDA 本身「簽署」轉移。 為此，我們：
- 創建 `signer_seeds`，一個對用於派生 PDA 的所有種子的引用數組。
- 將這些種子傳遞到 `CpiContext::new_with_signer` 中，允許 PDA 充當此 CPI 調用的簽署者。

其他一切都與存款完全相同，但方向相反。 這次，我們將從保險險中提取所有 lamports，將它們發送回簽署者。
